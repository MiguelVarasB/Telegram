(function () {
    const App = window.App = window.App || {};
    const dom = App.dom || {};
    const state = App.state || {};
    const behaviors = App.behaviors = App.behaviors || {};
    const btnSyncFaltantes = document.getElementById('btn-sync-faltantes');
    state.batchScan = state.batchScan || { jobId: null, total: 0, done: 0, running: 0 };

    function updateBatchButton(text, disabled) {
        if (!btnSyncFaltantes) return;
        btnSyncFaltantes.textContent = text;
        btnSyncFaltantes.disabled = !!disabled;
    }

    function formatBatchLabel() {
        if (!state.batchScan || !state.batchScan.jobId) return 'Sincronizar faltantes';
        const { done, total, running } = state.batchScan;
        return `Escaneando (${done}/${total}, ${running} activos)`;
    }

    // --- Event Listeners Globales ---
    function bindGlobalEvents() {
        if (dom.modalOverlay) {
            dom.modalOverlay.addEventListener('click', function (ev) {
                if (ev.target === dom.modalOverlay) behaviors.closeVideoModal?.();
            });
        }
        if (dom.modalClose) dom.modalClose.addEventListener('click', behaviors.closeVideoModal);

        if (dom.statsButton) dom.statsButton.addEventListener('click', behaviors.openStatsModal);
        if (dom.statsOverlay) {
            dom.statsOverlay.addEventListener('click', function (ev) {
                if (ev.target === dom.statsOverlay) behaviors.closeStatsModal?.();
            });
        }
        if (dom.statsClose) dom.statsClose.addEventListener('click', behaviors.closeStatsModal);

        if (dom.downloadsButton) dom.downloadsButton.addEventListener('click', behaviors.openDownloadsModal);
        if (dom.downloadsOverlay) {
            dom.downloadsOverlay.addEventListener('click', function (ev) {
                if (ev.target === dom.downloadsOverlay) behaviors.closeDownloadsModal?.();
            });
        }
        if (dom.downloadsClose) dom.downloadsClose.addEventListener('click', behaviors.closeDownloadsModal);

        if (dom.hideVideoButton) {
            dom.hideVideoButton.addEventListener('click', function () {
                if (!state.currentVideoId || !state.currentVideoElement || !state.hiddenVideos) return;

                const isHidden = state.hiddenVideos.has(state.currentVideoId);
                if (isHidden) {
                    state.hiddenVideos.delete(state.currentVideoId);
                    state.currentVideoElement.dataset.hidden = '0';
                    state.currentVideoElement.classList.remove('is-hidden-video');
                } else {
                    state.hiddenVideos.add(state.currentVideoId);
                    state.currentVideoElement.dataset.hidden = '1';
                    state.currentVideoElement.classList.add('is-hidden-video');
                }
                behaviors.saveHiddenVideos?.();
                behaviors.updateHideVideoButton?.();
                behaviors.applyDuplicateFilter?.();
            });
        }

        // Tecla Escape
        document.addEventListener('keydown', function (event) {
            if (event.key !== 'Escape') return;
            if (dom.statsOverlay && dom.statsOverlay.classList.contains('is-open')) {
                behaviors.closeStatsModal?.();
                return;
            }
            if (dom.downloadsOverlay && dom.downloadsOverlay.classList.contains('is-open')) {
                behaviors.closeDownloadsModal?.();
                return;
            }
            if (dom.modalOverlay && dom.modalOverlay.classList.contains('is-open')) {
                behaviors.closeVideoModal?.();
            }
        });
    }

    // --- Conexión de Carpeta: MQTT o WebSocket ---
    function setupFolderConnection() {
        try {
            const container = document.querySelector('.container[data-folder-id]');
            if (!container) return;
            const folderId = container.getAttribute('data-folder-id');
            if (!folderId) return;

            // Priorizar MQTT sobre WebSocket
            if (window.App && window.App.mqttClient && window.App.mqttClient.isConnected()) {
                console.log(`[Main] Usando MQTT para carpeta ${folderId}`);
                setupFolderMQTT(folderId);
            } else {
                console.log(`[Main] MQTT no disponible, usando WebSocket para carpeta ${folderId}`);
                setupFolderWS();
            }
        } catch (e) {
            console.warn('[Main] Error en setupFolderConnection', e);
        }
    }

    // --- MQTT de carpeta ---
    function setupFolderMQTT(folderId) {
        const client = window.App.mqttClient;
        if (!client) return;

        const scanTopic = `bot/folder/${folderId}/scan`;
        const refreshTopic = `bot/folder/${folderId}/refresh`;

        client.subscribe(scanTopic, (payload, topic) => {
            handleFolderMessage(payload, folderId);
        }, 1);

        client.subscribe(refreshTopic, (payload, topic) => {
            if (payload.type === 'refresh') {
                reloadFolderItems();
            }
        }, 0);

        console.log(`[Main] Suscrito a MQTT para carpeta ${folderId}`);
    }

    // --- Función de recarga de carpeta (para MQTT) ---
    function reloadFolderItems() {
        const container = document.querySelector('.container[data-folder-id]');
        if (!container) return;
        
        const folderId = container.getAttribute('data-folder-id');
        if (!folderId) return;
        
        fetch('/api/folder/' + encodeURIComponent(folderId))
            .then(res => {
                if (!res.ok) throw new Error('Error recargando carpeta');
                return res.json();
            })
            .then(data => {
                if (typeof window.renderItems === 'function') {
                    window.renderItems(data);
                } else {
                    console.error('renderItems no disponible');
                }
            })
            .catch(e => {
                console.error('Error recargando carpeta:', e);
            });
    }

    // --- Manejar mensajes de carpeta (común para MQTT y WebSocket) ---
    function handleFolderMessage(payload, folderId) {
        if (!payload || !payload.type) return;
        
        if (payload.type === 'init' || payload.type === 'refresh') {
            if (Array.isArray(payload.items)) {
                if (typeof window.renderItems === 'function') {
                    window.renderItems(payload.items);
                }
            }
        }
        if (payload.type === 'batch_scan_start') {
            state.batchScan = {
                jobId: payload.job_id,
                total: payload.total || 0,
                done: 0,
                running: 0,
            };
            updateBatchButton(formatBatchLabel(), true);
        }
        if (payload.type === 'batch_scan_update' && state.batchScan.jobId === payload.job_id) {
            state.batchScan.done = payload.done ?? state.batchScan.done;
            state.batchScan.running = payload.running ?? state.batchScan.running;
            updateBatchButton(formatBatchLabel(), true);
        }
        if (payload.type === 'batch_scan_done' && state.batchScan.jobId === payload.job_id) {
            state.batchScan.done = payload.done ?? state.batchScan.done;
            state.batchScan.running = 0;
            updateBatchButton('Sincronizar faltantes', false);
        }
        if (payload.type === 'scan_done' && payload.chat_id) {
            if (window.App?.state?.channelModalData?.chatId == payload.chat_id) {
                if (typeof window.App?.behaviors?.fillChannelMeta === 'function') {
                    window.App.behaviors.fillChannelMeta({
                        type: window.App.state.channelModalData.chatType,
                        username: window.App.state.channelModalData.username,
                        indexed_videos: payload.indexed_videos,
                        total_videos: payload.total_videos,
                        scanned_at: new Date().toISOString(),
                        last_message_date: window.App.state.channelModalData.lastMessage,
                    });
                }
                const statusEl = document.getElementById('channel-modal-status');
                if (statusEl) statusEl.textContent = 'Escaneo finalizado';
            }
        }
    }

    // --- WebSocket de carpeta ---
    function setupFolderWS() {
        try {
            const container = document.querySelector('.container[data-folder-id]');
            if (!container) return;
            const folderId = container.getAttribute('data-folder-id');
            if (!folderId) return;
            if (folderId !== '-1') return;

            const loc = window.location;
            const proto = (loc.protocol === 'https:') ? 'wss:' : 'ws:';
            const wsUrl = proto + '//' + loc.host + '/ws/folder/' + encodeURIComponent(folderId);
            const ws = new WebSocket(wsUrl);

            ws.onmessage = function (event) {
                try {
                    const payload = JSON.parse(event.data);
                    handleFolderMessage(payload, folderId);
                } catch (e) {
                    console.error('WS folder message parse error', e);
                }
            };
        } catch (e) {
            console.warn('WS folder setup error', e);
        }
    }

    // --- Sincronización de Carpeta (Renderizado Optimizado) ---
    function setupLiveFolderUpdates() {
        const container = document.querySelector('.container[data-folder-id]');
        if (!container) return;

        const folderId = container.getAttribute('data-folder-id');
        if (!folderId) return;

        const grid = container.querySelector('.grid-view');
        if (!grid) return;

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // ==========================================
        //  RENDERIZADO POR LOTES (LA OPTIMIZACIÓN)
        // ==========================================
        function renderItems(items) {
            if (!Array.isArray(items)) return;
            
            // 1. Limpiamos el grid una sola vez
            grid.innerHTML = '';
            
            const BATCH_SIZE = 50; // Procesar de 50 en 50
            let currentIndex = 0;

            function processBatch() {
                // Tomar el siguiente lote
                const batch = items.slice(currentIndex, currentIndex + BATCH_SIZE);
                
                // Si no quedan items, terminamos
                if (batch.length === 0) {
                    finishRendering(items);
                    return;
                }

                let html = '';
                batch.forEach(function (item) {
                    // --- TU LÓGICA DE PLANTILLA ORIGINAL ---
                    const i_folderId = item.folder_id || '';
                    const chatId = item.chat_id || '';
                    const faltantes = item.faltantes || 0;
                    const indexed = item.indexed_videos || '0';
                    const total = item.total_videos || '0';
                    const scannedAt = item.scanned_at || '';
                    const chatType = item.chat_type || '';
                    const lastMsg = item.last_message_date || '';
                    const username = item.username || '';
                    const name = escapeHtml(item.name || '');
                    const count = escapeHtml(item.count || '');
                    const link = item.link || '#';
                    const type = item.type || 'chat';
                    const photoId = item.photo_id;
                    const photoUrl = item.photo_url || (photoId ? ('/api/photo/' + encodeURIComponent(photoId) + '?tipo=grupo') : null);
                    const telegramLink = item.telegram_link || '';
                    const placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

                    if (type === 'video') {
                        const videoId = item.video_id || '';
                        const streamUrl = item.stream_url || (item.link || '').replace('/play/', '/video_stream/');

                        html += '<div class="file-item" data-item-type="video"'
                            + ' data-stream-url="' + escapeHtml(streamUrl) + '"'
                            + (videoId ? ' data-video-id="' + escapeHtml(videoId) + '"' : '')
                            + (chatId ? ' data-chat-id="' + escapeHtml(chatId) + '"' : '')
                            + '>';

                        html += '<a href="' + link + '" class="video-thumb-link" aria-label="Abrir video">'
                            + '<div class="icon-box video-box">'
                            + '<div class="video-hidden-indicator" title="Marcado como oculto">'
                            + '<i class="fas fa-eye-slash"></i>'
                            + '</div>'
                            + '<div class="video-loading-spinner" aria-hidden="true">'
                            + '<i class="fas fa-circle-notch fa-spin"></i>'
                            + '</div>';

                        if (photoId) {
                            html += '<img src="/api/photo/' + encodeURIComponent(photoId) + '?chat_id='
                                + encodeURIComponent(chatId) + '&video_id=' + encodeURIComponent(videoId)
                                + '" class="video-thumb" loading="lazy">';
                        } else {
                            html += '<i class="fas fa-file-video file-video"></i>';
                        }

                        if (item.duration_text) {
                            html += '<div class="video-duration">' + escapeHtml(item.duration_text) + '</div>';
                        }

                        html += '</div></a>'
                            + '<div class="file-name" title="' + name + '">' + name + '</div>'
                            + '<div class="file-info">' + count + '</div>'
                            + '</div>';
                    } else {
                        html += '<a href="' + link + '" class="file-item"'
                            + ' data-item-type="' + escapeHtml(type) + '"'
                            + ' data-chat-id="' + escapeHtml(chatId) + '"'
                            + ' data-faltantes="' + escapeHtml(faltantes) + '"'
                            + ' data-indexed="' + escapeHtml(indexed) + '"'
                            + ' data-total="' + escapeHtml(total) + '"'
                            + ' data-scanned-at="' + escapeHtml(scannedAt) + '">';

                        if (telegramLink) {
                            html += '<span class="btn-open-telegram" data-telegram-link="' + escapeHtml(telegramLink) + '" title="Abrir en Telegram">'
                                + '<i class="fa-brands fa-telegram"></i>'
                                + '</span>';
                        }

                        html += '<div class="icon-box folder-box">'
                            + '<i class="fas fa-folder folder-chat folder-icon"></i>';
                        if (photoUrl) {
                            html += '<img src="' + placeholder + '" data-src="' + escapeHtml(photoUrl)
                                + '" class="profile-img folder-overlay lazy-chat-photo" loading="lazy">';
                        }
                        html += '</div>'
                            + '<div class="file-name" title="' + name + '">' + name + '</div>'
                            + '<div class="file-info">' + count + '</div>';

                        if (i_folderId) {
                            html += '<button type="button"'
                                + ' class="btn-sync open-channel-modal"'
                                + ' onclick="return window.openChannelModalFromButton && window.openChannelModalFromButton(this);"'
                                + ' data-chat-id="' + escapeHtml(chatId) + '"'
                                + ' data-chat-name="' + name + '"'
                                + ' data-indexed="' + escapeHtml(indexed) + '"'
                                + ' data-total="' + escapeHtml(total) + '"'
                                + ' data-scanned-at="' + escapeHtml(scannedAt) + '"'
                                + ' data-chat-type="' + escapeHtml(chatType) + '"'
                                + ' data-last-message="' + escapeHtml(lastMsg) + '"'
                                + ' data-username="' + escapeHtml(username) + '"'
                                + ' data-telegram-link="' + escapeHtml(telegramLink) + '">'
                                + 'Info / Indexar'
                                + '</button>';
                        }
                        if(folderId==-1){
                            if(btnSyncFaltantes) btnSyncFaltantes.style.display='';
                        }

                        html += '</a>';
                    }
                });

                // Inyectamos este lote en el DOM
                grid.insertAdjacentHTML('beforeend', html);
                
                // Avanzamos el índice
                currentIndex += BATCH_SIZE;

                // Programamos el siguiente lote para el próximo frame de animación
                // Esto libera el hilo principal para que el navegador responda a clicks/scroll
                requestAnimationFrame(processBatch);
            }

            // Iniciamos el proceso
            processBatch();
        }

        function finishRendering(items) {
            // Re-aplicar comportamientos una vez renderizado todo (o el lote final)
            if (items.some((it) => it.folder_id)) {
                grid.querySelectorAll('.btn-sync.open-channel-modal').forEach((btn) => {
                    btn.style.display = '';
                });
            }
            if (window.refreshLazyChatPhotos) window.refreshLazyChatPhotos();
            behaviors.applyHiddenStateToAll?.();
            behaviors.applyDuplicateFilter?.();
            behaviors.applyWatchLaterStateToAll?.();
            behaviors.setupLazyChatPhotos?.();
            behaviors.setupHoverPreviews?.();
        }

        window.renderItems = renderItems;

        if (folderId === '-1') {
            return;
        }

        async function fetchAndRender() {
            try {
                const res = await fetch('/api/folder/' + encodeURIComponent(folderId));
                if (!res.ok) {
                    console.error('Error recargando carpeta', res.status);
                    return;
                }
                const data = await res.json();
                renderItems(data);
            } catch (e) {
                console.error('Error fetch /api/folder', e);
            }
        }

        const loc = window.location;
        const proto = (loc.protocol === 'https:') ? 'wss:' : 'ws:';
        const limitInput = document.getElementById('search-limit');
        const urlParams = new URLSearchParams(loc.search);
        const limitFromUrl = urlParams.get('limite') || urlParams.get('limit');
        const limitValue = (limitInput && limitInput.value) || limitFromUrl || '';
        const wsQuery = limitValue ? ('?limite=' + encodeURIComponent(limitValue)) : '';
        const wsUrl = proto + '//' + loc.host + '/ws/folder/' + encodeURIComponent(folderId) + wsQuery;

        let ws;
        try {
            ws = new WebSocket(wsUrl);
        } catch (e) {
            console.error('No se pudo abrir WebSocket de carpeta', e);
            return;
        }

        ws.onmessage = function (event) {
            try {
                const payload = JSON.parse(event.data);
                if (payload && payload.type === 'refresh') {
                    fetchAndRender();
                }
            } catch (e) {
                console.error('Mensaje WS inválido', e);
            }
        };

        window.addEventListener('beforeunload', function () {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.close();
                }
            } catch (e) {}
        });

        fetchAndRender();
    }

    // --- Trigger batch scan ---
    behaviors.triggerBatchScan = async function triggerBatchScan() {
        const container = document.querySelector('.container[data-folder-id]');
        const folderId = container?.getAttribute('data-folder-id') || null;
        const cards = Array.from(document.querySelectorAll('.file-item[data-chat-id]'))
            .filter((el) => Number(el.dataset.faltantes || 0) > 0)
            .sort((a, b) => {
                const ta = Number(a.dataset.total || 0);
                const tb = Number(b.dataset.total || 0);
                if (ta !== tb) return ta - tb;
                const fa = Number(a.dataset.faltantes || 0);
                const fb = Number(b.dataset.faltantes || 0);
                if (fa !== fb) return fa - fb;
                return Number(a.dataset.chatId || 0) - Number(b.dataset.chatId || 0);
            });
        if (!btnSyncFaltantes) return;
        if (!cards.length) {
            updateBatchButton('Nada que sincronizar', true);
            setTimeout(() => updateBatchButton('Sincronizar faltantes', false), 1500);
            return;
        }
        const chatIds = cards.map((el) => Number(el.dataset.chatId)).filter((n) => Number.isFinite(n));
        updateBatchButton(`Enviando (${chatIds.length})...`, true);
        try {
            const res = await fetch('/api/folder/scan-batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_ids: chatIds,
                    folder_id: folderId ? Number(folderId) : null,
                }),
            });
            if (!res.ok) throw new Error('scan-batch failed');
            const data = await res.json();
            state.batchScan = {
                jobId: data.job_id,
                total: data.total || chatIds.length,
                done: 0,
                running: 0,
            };
            updateBatchButton(formatBatchLabel(), true);
        } catch (e) {
            console.error('Error batch scan', e);
            updateBatchButton('Error al iniciar', true);
            setTimeout(() => updateBatchButton('Sincronizar faltantes', false), 2000);
        }
    };

    function init() {
        behaviors.setupHoverPreviews?.();
        setupLiveFolderUpdates();
        behaviors.applyHiddenStateToAll?.();
        behaviors.applyDuplicateFilter?.();
        behaviors.applyWatchLaterStateToAll?.();
        behaviors.setupLazyChatPhotos?.();
        behaviors.initSearchHandlers?.();
        setupFolderConnection();
        bindGlobalEvents();

        const btnSync = document.getElementById("btn-sync-diario");
        if (btnSync) {
            btnSync.addEventListener("click", async () => {
                btnSync.disabled = true;
                btnSync.textContent = "Sincronizando...";
                try {
                    await fetch("/sync/diario", { method: "POST" });
                    alert("Sincronización completada");
                } catch (e) {
                    console.error("Error sync diario", e);
                    alert("Error al sincronizar");
                } finally {
                    btnSync.disabled = false;
                    btnSync.textContent = "Sincronizar diario";
                }
            });
        }
        updateBatchButton('Sincronizar faltantes', false);
    }

    init();
})();

async function toggleWatchLater(e, itemId) {
    e.preventDefault();
    e.stopPropagation();
    const card = e.currentTarget.closest('.file-item');
    const behaviors = window.App?.behaviors;
    const current = card?.dataset.watchLater === '1';
    const nextValue = !current;
    try {   
        const res = await fetch(`/api/video/${encodeURIComponent(itemId)}/watch_later`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ value: nextValue }),
        });
        const text = await res.text();
        if (!res.ok) throw new Error(`watch_later ${res.status}: ${text}`);
        let data;
        try { data = JSON.parse(text); } catch { data = {}; }
        const saved = data.watch_later ? '1' : '0';
        if (card) {
            card.dataset.watchLater = saved;
            behaviors?.applyWatchLaterStateToElement?.(card);
        }
    } catch (err) {
        console.error('Error al marcar ver después', err);
        alert('No se pudo actualizar "ver más tarde". Intenta nuevamente.');
    }
}